//함수 표현식 방식으로 함수 생성하기.
/*
  자바스크립트에서는 함수도 하나의 값처럼 취급
  (이러한 특징이므로 자바스크립트의 함수는 일급 객체라고 한다.)
  따라서 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능하다.

  함수 리터럴로 하나의 함수를 만들고, 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 함수 표현식(function expression)이라고 한다.

  다음 예제는 add() 함수를 함수 표현식 형태로 생성한 것이다.
  함수 리터럴로 두 값을 더하는 함수를 생성한 다음, 이를 add 변수에 저장한 것이다.
  함수 리터럴로 생성한 함수는 함수명이 없으므로 익명 함수이다.
*/

var add = function(x, y) {
    return x + y;
};

var plus = add;

console.log(add(2, 3)); //5
console.log(plus(3, 4)); //7

/*
  함수 표현식(function expression)은 함수 선언문(function statement) 문법과 거의 유사하다.
  차이점은 함수 표현식에서는 함수 이름이 선택 사항이며, 보통 사용하지 않는다.

  1. add 변수는 함수 리터럴로 생성한 함수를 참조하는 변수이지, 함수 이름이 아니다. 함수 변수라고 하겠다.
  2. 함수 변수 add는 함수의 참조값을 가지므로 또 다른 변수 plus에도 그 값을 그대로 할당할 수가 있다.
  3. 함수 표현식으로 생성된 함수를 호출하려면 함수 변수를 사용해야 한다.
  4. plus또한 add 함수 변수와 같은 함수를 참조하는 함수 변이므로 plus(3,4)과 같은 형태로 함수를 호출하는 것이 가능하다.

  ** add와 plus함수 변수는 두 개의 인자를 더하는 동일한 익명 함수를 '참조'한다.

  함수 변수 add가 실제로 참조하는 두 수를 더하는 함수의 이름이 없다. 익명 함수이다.
  즉, 인자로 넘겨진 두 수를 더하는 익명 함수를 만들고 이를 add 변수에 할당한 것이다.
  이것이 바로 익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)이다.
  익명 함수의 호출은 앞 예제와 같이 함수 변수에 함수 호출 연산자인 ()를 붙여서 사용이 가능하다.

  함수 이름이 포함된 함수 표현식을 기명 함수 표현식이라고 한다. 기명 함수 표현식 사용시에는 주의점이 있다.
*/

var add = function sum(x, y) {
    return x + y;
};

console.log(add(3,4)); // 7
//console.log(sum(3,4)); // error

/*
    add()함수 호출은 성공적인 리턴
    sum()함수 호출의 경우 에러
    함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능하기 떄문이다.

    실제로 함수 표현식에서 사용된 함수 이름은 정의된 함수 내부에서 해당 함수를 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용된다.
    따라서 함수 이름으로 사용된 sum으로 함수 외부에서 해당 함수를 호출할 때 sum() 함수가 정의되어 있지 않다는 에러가 발생한다.
*/

/*
    그럼 함수 선언문으로 정의한 add()함수는 어떻게 함수 이름으로 외부에서 호출이 가능할까?
*/

var add = function add(x, y) {
    return x + y;
};

/*
    위와 같이 함수 선언문 형식으로 정의된 add() 함수는 자바스크립트 엔진에 의해 함수 표현식 형태로 변경되기 떄문이다.
    함수 이름과 함수 변수가 add로 같으므로, 함수 이름으로 함수가 호출되는 것처럼 보이지만, !!실제로는 add 함수 변수로 함수 외부에서 호출이 가능하게 된 것이다.
*/

/*
    함수 이름을 이용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능하다.
*/

var factorialVar = function factorial(n) {
    if(n <= 1 ){
        return 1;
    }
    return n * factorial(n-1);
};

console.log(factorialVar(3));
//console.log(factorial(3));

/*
    함수 외부에서는 함부 변수 factorialVar로 함수를 호출했으며, 함수 내부에서 이뤄지는 재귀 호출은 factorial()함수 이름으로 처리한다는 것을 알 수 있다.
    앞서 마찬가지로 함수명 factorial()으로 함수 외부에서 해당 함수를 호출하지 못해 에러가 발생한다.
*/

//function statement와 function expression에서의 세미콜론
/*
    일반적으로 자바스크립트 코드를 작성할 때 함수 선언문 방식으로 선언된 함수의 경우는 함수 끝에 세미콜론(;)을 붙이지 않지만,
    함수 표현식 방식의 경우는 세미콜린(;)을 붙이는 것을 권장한다.
*/

var func = function() {
    return 42;
}; //세미콜론을 사용하지 않음
(function() {
    console.log("function called");
})();

/*
    func()의 함수 정의에서 세미콜론을 사용하지 않아, return 42; 문장을 지나 func()의 함수 정의 끝에 있는 중괄호(})만으로 func()함수가 끝났다고 판한하지 않기 때문
    그리고 자바스크립트 파서는 이후에 괄호에 둘러싸여 정의된 즉시 실행 함수를 보고 이를 마치 func() 함수 호출 연산으로 생각해서 func() 함수를 호출
    func()  함수가 호출되면 42가 반환, 즉시 실행 함수를 실행하려고 남겨둔 마지막 () 괄호가 있으므로 42(); 형태로 또다시 함수를 호출할려고 시도한다.
    이런 문제로 인해 세미콜론 사용 추천
*/

// Function() 생성자 함수를 통한 함수 생성하기
/*
    자바스크립트의 함수도 Function()이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다.
    앞에서 설명한 함수 선언문이나 함수 표현식 방식도 Function() 생성자 함수가 아닌 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 이 또한 내부적으로 Function() 생성자 함수
    로부 함수가 생성된다고 볼 수 있다.

    Function() 생성자 함수로 함수를 생성하는 문법은 다음과 같다.
*/

/*
    new Function(arg1, arg2, ... argN, functionBody)

    arg1, arg2 ... 함수의 매개변수
    functionBody ... 함수가 호출 될때 실행될 코드를 포함한 문자열
*/

var add = new Function('x', 'y', 'return x + y');
console.log(add(3,4));

//일반적으로 생성자 함수를 사용한 함수 생성 방법은 사용되지 않으나 기본 상식으로 알아두자.

//함수 호이스팅
/*
    함수를 생성하는 3가지 방법을 살펴봤다. 하지만 이들 사이에는 동작 방식이 약간 차이가 있다.
    그게 바로 함수 호이스팅(Function hoisting)이다.

    이러한 이유로 더글라스 크락포드는 함수 표현식만을 사용할 것을 권고하고 있다.
*/

add(2,3);

function add(x, y) {
    return x + y;
}

add(3,4);

/*
    add(2,3); 시점에서 add() 함수가 정의되지 않았음에도 정의된 add()함수를 호출하는 것이 가능하다.
    이 것은 함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다는 것을 확인 할 수 있다.
    이것을 함수 호이스팅이라 부른다.
*/

add(2,3);

var add = function (x,y) {
    return x + y;
}

add(3,4);

/*
    add()함수는 함수 표현식 형태로 정의되어 있어 함수 호이스팅이 발생하지 않는다. 함수가 생성된 이후에 호출이 가능하다.

    ** 함수 호이스팅이 발생하는 원인은 자바스크립트의 변수 생성과 초기화의 작업이 분리돼서 진행되기 때문이다. 이건 다음에 자세히 배우자.
*/
