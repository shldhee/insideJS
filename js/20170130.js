/*
  참조 타입의 특성
  자바스크립트에서는 기본 타입인 숫자, 문자열, 불린값, null, undefined 5가지를 제외한 모든 값은 '객체'다.
  배열이나 함수 또한 객체로 취급된다. 이러한 객체는 자바스크립트에서 참조 타입이라고 부른다.
  이것은 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문이다.
*/

var objA = {
  val: 40
};

var objB = objA;

console.log(objA.val); //40
console.log(objB.val); //40

objB.val = 50;

console.log(objA.val); //50
console.log(objB.val); //50

/*
  objA 객체를 객체 리터럴 방식으로 생성했다.
  여기서 objA 변수는 객체 자체를 저장하고 있는 것이 아니라 생성된 객체를 가리키즈는 참조값을 저장하고 있다는 것을 기억하자.

  변수 objB에 objA 값을 할당한다. ojbA는 생성된 객체를 가리키는 참조값을 가지고 있으므로 변수 objB에도 이같은 객체의 참조값이 저장된다.

  objB가 가리키는 객체의 val 값을 40에서 50으로 갱신했다. 이때 변수 objA도 변수 objB와 동일한 객체를 참조하고 있으므로 a.val값이 50으로 변경된 것을 확인할 수 있다.

  !! 위 예제처럼 변수 objA는 실제로는 객체를 참조하는 값을 저장할 뿐 실제 객체를 나타내지는 않는다.
*/

//객체 비교
/*
  동등 연산자(==)를 사용하여 두 객체를 비교할 때 객체의 프로퍼티값이 아닌 참조값을 비교한다는 것에 주의해야 한다.
*/

var a = 100;
var b = 100;

var objA = { value: 100 };
var objB = { value: 100 };
var objC = objB;

console.log(a == b); //true
console.log(objA == objB) ; //false;
console.log(objC == objB) ; //true;

/*
  a와 b는 숫자 100을 저장하고 있는 기본 타입의 변수다. 기본 타입의 경우 동등 연산자(==)를 이용해서 비교할때 값을 비교한다.
  두 변수 모두 100이라는 동일한 값을 가지고 있으므로 a==b의 결과는 true가 된다.

  objA와 objB는 다른객체지만, 같은 형태의 프로퍼티값을 가지고 있다. 하지만 동등 연산자(==)로 두 객체를 비교하면 결과는 false이다. 그 이유는 기본 타입의 경우는 값 자체를 비교해서 일치 여부를 판단하지만, 객체와 다른 참조 타입의 경우는 참조값이 같아야 true이다. 따라서 objB와 objC는 같은 객체를 참조하므로 동등 연산자(==) 결과가 true가 되는 것이다.
*/

// 참조에 의한 함수 호출 방식
/*
  기본 타입과 참조 타입의 경우는 함수 호출 방식도 다르다. 기본 타입의 경우는 값에 의한 호출 방식으로 동작한다. 즉, 함수를 호출할 때 인자로 기본 타입의 값을 넘길 경우, 호출된 함수의 매개변수로 복사된 값이 전달된다. 때문에 함수 내부에서 매개변수를 이용해 값을 변경해도, 실제로 호출된 변수의 값이 변경되지는 않는다.

  객채와 같은 참조 타입의 경우 함수를 호출할 때 참조에 의한 호출 방식으로 동작한다.
  즉, 함수를 호출할 때 인자로 참조 타입의 객체를 전달할 경우, 객체의 프로퍼티값이 함수의 매개변수로 복사되지 않고, 인자로 넘긴 객체의 참조값이 그대로 함수 내부로 전달된다. 때문에 함수 내부에서 참조값을 이용해서 인자로 넘긴 실제 객체의 값을 변경할 수 있다.
*/

var a = 100;
var objA = { value: 100 };

function changeArg(num, obj) {
  num = 200;
  obj.value = 200;

  console.log(num);
  console.log(obj);
}

changeArg(a, objA);

console.log(a);
console.log(objA);

/*
  changeArg() 함수를 호출하면서, 인자값으로 기본 타입인 숫자를 가진 변수 a와 참조타입인 객체 objA를 넘겼다.
  a와 objA.val의 값을 100에서 200으로 바꿨지만, 함수 호출이 끝난 후에는 참조타입인 객체의 objA.value 프로퍼티만이
  값이 변해 있다는 것을 확인할 수 있다.
*/

//프로토타입
/*
  자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 이것은 마치 객체지향의 상속 개념과 같이 부모 객체의
  프로퍼티를 마치 자신의 것처럼 쓸 수 있는 것 같은 특징이 있다.
  자바스크립트에서는 이러한 부모 객체를 프로토타입 객체(짧게는 프로포타입)이라고 부른다.
*/

var foo = {
  name: 'foo',
  age: 30
};

console.log(foo.toString());

console.dir(foo);

/*
  앞 예제는 단순히 객체 리터럴 방식으로 foo 객체를 생성하고, 이 객체의 toString() 메서드를 출력한 것이다.
  그러나 예제에서 생성한 foo 객체는 toString() 메서드가 없으므로 에러가 발생해야 하지만, 정상적으로 결과가 출력된다.
  에러가 발생하지 않고 예제가 실행될 수 있는 이유는 바로 foo 객체의 프로토타입에 toString() 메서드가 이미 정의되어 있고,
  foo 객체가 상속처럼 toString() 메서드를 호출하기 때문이다.
*/

/*
  console.dir(foo);
  실행결과를 살펴보면, 객체 리터럴로 생성한 name과 age 프로퍼티 이외에도 foo 객체에 _proto_프로퍼티가 있는다는 것을 확인할 수 있다.
  이 프로퍼티가 앞서 설명한 foo객체의 부모인 프로토타입 객체를 가리킨다. 이 객체의 다음 부분에 toString() 메서드가 정의되어 있다는 것을 알 수 있다.
*/

/*
  ECMAScript 명세서에는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]라는 숨겨진 프로퍼티를 가진다고 한다.
  크롬 브라우저에서는 __proto__ 가 바로 이 숨겨진 [[Prototype]]프로퍼티를 의미한다.
  즉, foo 객체는 자신의 부모 객체를 __proto__라는 내부 프로퍼티로 연결하고 있는 것이다.
*/

/*
  모든 객체의 프로토타입은 자바스크립트의 룰에 따라 객체를 생성할 때 결정된다.
  자세한건 뒤에서 살펴보자. 우선 객체 리터럴 방식으로 생성된 객체의 경우 Object.prototype 객체가 프로토타입 객체가 된다는것만 기억하자.

  위 예제에서 foo 객체의 __proto__ 프로퍼티가 가리키는 객체가 바로 Object.prototype 이며, toString(), valueOf() 등과 같은 모든 객체에서 호출 가능한 자바스크립트 기본 내장 메서드가 포함되어 있다.
  그 결과 foo 객체는 foo.toString() 과 같이 자신의 프로토타입인 Object.prototype 객체에 포함된 다양한 메서드를 마치 자신의
  프로퍼티인 것처럼 상속받아 사용할 수 있다.

  또한, 객체를 생성할 때 결정된 프로토타입 객체는 임의의 다른 객체로 변경하는 것도 가능하다.
  즉, 부모 객체를 동적으로 바꿀 수도 있는 것이다. 자바스크립트에서는 이러한 특징을 활용해서 객체 상속 등의 기능을 구현한다.
*/

//배열

/*
  배열은 자바스크립트 객체의 특별한 형태다. 즉, C나 자바의 배열과 같은 기능을 하는 객체지만, 이들과는 다르게 굳이 크기를 지정하지 않아도 되며, 어떤 위치에 어느 타입의 데이터를 저장하더라도 에러가 발생하지 않는다.
*/

//배열 리터럴

/*
  배열 리터럴은 자바스크립트에서 새로운 배열을 만드는데 사용하는 표기법이다.
  객체 리터릴이 중괄호 ({})를 이용한 표기법이었다면, 배열 리터럴은 대괄호([])를 사용한다.
*/

var colorArr = ['orange','yellow','green','red'];
console.log(colorArr[0]);
console.log(colorArr[1]);
console.log(colorArr[3]);

/*
  객체 리터럴에서는 프로퍼티 이름과 프로퍼티값 모두 표기해야 하지만, 배열 리터럴에서는 각 요소의 값만을 포함한다.
  객체가 프로퍼티의 이름으로 대괄호나 마침표 표기법을 이용해 해당 프로퍼티에 접근했다면, 배열의 경우는 앞 예제처럼 대괄호 내에
  접근하고자 하는 원소에 배열 내 위치 인덱스값을 넣어서 접근한다.
  배열 내의 첫 번째 원소는 인덱스 0부터 시작한다.
*/

//배열의 요소 생성

/*
  객체가 동적으로 프로퍼티를 추가할 수 있듯이, 배열도 동적으로 배열 원소를 추가할 수 있다.
  특히, 자바스크립트 배열의 경우는 값을 순차적으로 넣을 필요 없이 아무 인덱스 위치에나 값을 동적으로 추가할 수 있다.
*/

var emptyArr = [];
console.log(emptyArr[0]); // undefined

emptyArr[0] = 100;
emptyArr[3] = 'eight';
emptyArr[7] = true;
console.log(emptyArr);
console.log(emptyArr.length);

//배열의 length 프로퍼티
/*
  자바스크립트의 모든 배열은 length프로퍼티가 있다. length프로퍼티는 배열의 원소 개수를 나타내지만, 실제로 배열에 존재하는 원소 개수와
  일치하는 것은 아니다. 즉, length프로퍼티는 배열 내에 가장 큰 인덱스에 1을 더한 값이다.
  가장 큰 인덱스 값이 변하면, length 값 또한 자동으로 그에 맞춰 변경된다.
*/

var arr = [];
console.log(arr.length);

arr[0] = 0;
arr[1] = 1;
arr[2] = 2;
arr[100] = 100;
console.log(arr.length);

/*
  배열의 length 프로퍼티는 코드를 통해 명시적으로 값을 변경할 수도 있다.
*/

var arr = [0,1,2];
console.log(arr.length); //3

arr.length = 5;
console.log(arr); // [0,1,2, undefined, undefined] -> [0,1,2] 최신 브라우저 콘솔
console.log(arr.length);

arr.length = 2;
console.log(arr);
console.log(arr[2]);

//배열 표준 메서드와 length 프로퍼티
/*
  자바스크립트는 배열에서 사용 가능한 다양한 표준 메서드를 제공한다. 이러한 배열 메서드는 length프로퍼티를 기반으로 동작한다.
  push()메서드는 인수로 넘어온 항목을 배열의 끝에 추가하는 자바스크립트 표준 배열 메서드다.
  이 메서드는 배열의 현재 length 값의 위치에 새로운 원소값을 추가한다.
  배열의 length프로퍼티는 '현재 배열의 맨 마지막 원소의+1'을 의미하므로 결국 length 프로퍼티가 가리키는 인덱스에 값을
  저장하는 것은 배열의 끝에 값을 추가하는 것과 같은 결과가 되기 때문이다.
*/

var arr = ['zero','one','two'];

arr.push('three');
console.log(arr);

arr.length = 5;
arr.push('four');
console.log(arr);

/*
  push()메서드는 현재 변경된 arr.length가 가리키는 배열의 5번째 인덱스, arr[5]에 'four'문자열을 추가하게 된다.
  이렇듯 배열의 length 프로퍼티는 배열 메서드에 동작에 영향을 줄 수 있을만큼 배열에서는 중요한 프로퍼티이므로 반드시 기억하자.
*/


//배열과 객체
/*
  자바스크립트에서 배열 역시 객체다.
  하지만 일반 객체와는 약간 차이가 잇다.
*/
